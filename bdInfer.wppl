var getNodeAges = function(tree){
	if(tree.children.length==0){
		return []
	}
	var leftAges = getNodeAges(tree.children[0])
	var rightAges = getNodeAges(tree.children[1])
	var leftChildAge = leftAges.length==0 ? 0.0 : leftAges[leftAges.length - 1]
	var curAge = leftChildAge + tree.children[0].branch_length
	return leftAges.concat(rightAges).concat([curAge])
}

var expTerm = function(t, lambda, mu){
	return Math.exp(-(lambda-mu)*t)
}

var p_0 = function(t, lambda, mu){
	var expterm = expTerm(t, lambda, mu)
	return mu * (1.0 - expterm)/(lambda - mu*expterm)
}


var log_p_0 = function(t, lambda, mu){
	return Math.log(p_0(t, lambda, mu))
}

// need this for the case mu = 0
var p_0_div_mu = function(t, lambda, mu){
	var expterm = expTerm(t, lambda, mu)
	return (1.0 - expterm)/(lambda - mu*expterm)
}

var log_p_0_div_mu = function(t, lambda, mu){
	return Math.log(p_0_div_mu(t, lambda, mu))
}


var p_1 = function(t, lambda, mu){
	var r = lambda - mu
	var sqrtDenom = lambda - mu * expTerm(t, lambda, mu)
	return r*r*expterm/(sqrtDenom*sqrtDenom)
}

var log_p_1 = function(t, lambda, mu){
	var r = lambda - mu
	var logr = Math.log(r)
	var expterm = expTerm(t, lambda, mu)
	var logDenom = 2.0 * Math.log(lambda - mu * expterm)
	return 2.0*logr - (lambda - mu)*t - logDenom
}

var p_n = function(t, n, lambda, mu){
	var rho = lambda/mu
	return Math.pow(rho,n-1)*p_1(t,lambda,mu)*Math.pow(p_0(t,lambda,mu),n-1)
}

var log_p_n = function(t,n,lambda,mu){
	var logLambda = Math.log(lambda)
	var logMu = Math.log(mu)
	return (n-1)*(logLambda-logMu)+log_p_1(t,lambda,mu) + (n-1)*log_p_0(t,lambda,mu)
}


// the likelihood of a specific tree (as opposed to just the branching times)
// following Gernhard 2007, this is the likelihood conditional on the age of the first speciation 
// AND the number of surviving taxa
var logLhoodFromSortedAges = function(sortedAges, lambda, mu){
	var logP1Terms = map(function(x){return log_p_1(x, lambda, mu)},sortedAges.slice(0,sortedAges.length-1))
	//console.log(logP1Terms)
	var t = sortedAges[sortedAges.length - 1]
	//console.log(log_p_0(t, lambda, mu))
	//console.log(log_p_0_div_mu(t, lambda, mu))
	var ll = sum(logP1Terms) - (sortedAges.length-1)*log_p_0_div_mu(t, lambda, mu)
	console.log("lambda = "+lambda.toString()+" mu = "+mu.toString()+" ll = "+ll.toString())
	return ll

}

// The inverse of the node age CDF for the birth-death process
// Used for sampling node ages
// Based on the point process representation of the BDP from Gernhard (2007), Eq. 3 on p. 9
var inverseCDFNodeAge = function(y, t, lambda, mu){
	var expterm = expTerm(t, lambda, mu)
	// normalizing constant
	var C = (lambda - mu * expterm)/(1.0 - expterm)
	var s = - (Math.log(C - y*lambda) - Math.log(C - y*mu))/(lambda - mu)
	return s
}

var CDFNodeAge = function(s, t, lambda, mu){
	var exptermT = expTerm(t, lambda, mu)
	var exptermS = expTerm(s, lambda, mu)
	// normalizing constant
	var C = (lambda - mu * exptermT)/(1.0 - exptermT)
	var y = C * (1.0 - exptermS)/(lambda - mu *exptermS)
	return y
}


var logDensityNodeAge = function(s, t, lambda, mu){
	var exptermT = expTerm(t, lambda, mu)
	var exptermS = expTerm(s, lambda, mu)

	var logr = Math.log(lambda - mu)
	return 2.0*logr - (lambda - mu)*s + Math.log(lambda - mu*exptermT) - 2.0*Math.log(lambda - mu*exptermS) - Math.log(1.0 - exptermT)

}



var getSortedNodeAges = function(tree){
	var ages = getNodeAges(tree)
	var sortedAges = sort(ages)
	return sortedAges
}



var sampleTime = function(t, lambda, mu){
	var y = sample(Uniform({a:0.0, b:1.0}))
	var s = inverseCDFNodeAge(y, t, lambda, mu)
	return s
}

var sampleTimes = function(n_times, t, lambda, mu){
	return repeat(n_times,function(){return sampleTime(t, lambda, mu)})
}

var generateBDTimes = function(sortedAges){
	var lambda = sample(Gamma({shape:4.0, scale:0.25}))
	var mu = sample(Uniform({a:0.0, b:lambda}))
	var n = sortedAges.length - 1
	var t = sortedAges[sortedAges.length -1]

	var sampleTimesFun = function(){ sampleTimes(n, t, lambda, mu) }
	var agesDist = Infer({model: sampleTimesFun, method: "MCMC"})

	observe(agesDist,sortedAges.slice(0,sortedAges.length-1))
	return {lambda: lambda, mu: mu}

}

var observeUnif = function(unifAges){
	if(unifAges.length == 0){
		return 0
	}
	observe(Uniform({a:0.0,b:1.0}),unifAges[0])
	return observeUnif(unifAges.slice(1,unifAges.length))
}

var observeByFactor = function(ages, t, lambda, mu){
	if(ages.length == 0){
		return 0
	}
	factor(logDensityNodeAge(ages[0], t, lambda, mu))
	return observeByFactor(ages.slice(1,ages.length),t,lambda,mu)

}

var gaussianKernel = function(prevVal) {
  //console.log("drift Kernel")
  return Gaussian({mu: prevVal, sigma: 0.01});
}

var generateBDTimesMapToUnif = function(sortedAges){
	//var lambda = sample(Uniform({a:0.01, b:1.0}),{driftKernel:gaussianKernel})
	var lambda = sample(Uniform({a:0.0, b:1.0}),{driftKernel:gaussianKernel})
	var mu = sample(Uniform({a:0.0, b:lambda}),{driftKernel:gaussianKernel})
	var n = sortedAges.length - 1
	var t = sortedAges[sortedAges.length -1]

	var uniformizedAges = map(function(x){return CDFNodeAge(x,t,lambda,mu)},sortedAges.slice(0,sortedAges.length-1))
	observeUnif(uniformizedAges)
	console.log("lambda = "+lambda.toString()+" mu ="+mu.toString())
	return {lambda:lambda,mu:mu}

}

var generateBDTimesFactor = function(sortedAges){
	var lambda = sample(Uniform({a:0.0, b:10.0}),{driftKernel:gaussianKernel})
	var mu = sample(Uniform({a:0.0, b:lambda}),{driftKernel:gaussianKernel})
	var n = sortedAges.length - 1
	var t = sortedAges[sortedAges.length -1]

	observeByFactor(sortedAges, t, lambda, mu)
	console.log("lambda = "+lambda.toString()+" mu ="+mu.toString())
	return {lambda:lambda,mu:mu}
}




//var json_file = "nexus2phyjson/nexus2phyjson/basic2.phyjson"
display(argv)
var json_file = argv.tree //"data/synthetic/tree_n16_b0.1_e0.0_2.phyjson"
var phyjson = JSON.parse(fs.readFileSync(json_file, "utf8"))
var nodeAges = getSortedNodeAges(phyjson.trees[0].root)
var tOrigin = nodeAges[nodeAges.length-1]
var lambda = 0.1
var mu = 0.0


//var samples = Infer({model: function(){return generateBDTimesMapToUnif(nodeAges)}, method:"MCMC", kernel: "MH", samples:1000,burn:500,lag:10})
var samples = Infer({model: function(){return generateBDTimesFactor(nodeAges)}, method:"MCMC", samples:10000,burn:5000,lag:100})
logLhoodFromSortedAges(nodeAges, 1.0, 0.00) //+ log_p_n(nodeAges[nodeAges.length-1],nodeAges.length+1,0.1,0.02)
logLhoodFromSortedAges(nodeAges, 0.5, 0.00)
logLhoodFromSortedAges(nodeAges, 1.0, 0.7)
logLhoodFromSortedAges(nodeAges, 1.0, 0.2)

fs.writeFile("results/synthetic",samples.toString(),function(err){
	return 0;
})
